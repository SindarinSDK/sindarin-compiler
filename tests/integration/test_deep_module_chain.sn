// Test: Deep module import chain (15 levels)
// Tests complex module imports, static/non-static variables, struct instances,
// aliased imports, and cross-module state management.

import "./imports/deep_chain/level_01" as L1
import "./imports/deep_chain/level_01" as L1_alias  // Same module, different alias
import "./imports/deep_chain/level_05" as MainL5
import "./imports/deep_chain/level_10" as MainL10
import "./imports/deep_chain/level_15" as MainL15
import "./imports/deep_chain/level_15" as MainL15_alias  // Same module, different alias

fn test_basic_level_ids(): void =>
    print("test_basic_level_ids: ")
    assert(L1.getLevelId() == 1, "L1 should have level id 1")
    assert(MainL5.getLevelId() == 5, "L5 should have level id 5")
    assert(MainL10.getLevelId() == 10, "L10 should have level id 10")
    assert(MainL15.getLevelId() == 15, "L15 should have level id 15")
    print("PASS\n")

fn test_static_counters_initial(): void =>
    print("test_static_counters_initial: ")
    // Static counters should have their initial values
    assert(L1.getStaticCounter() == 100, "L1 static counter should be 100")
    assert(MainL5.getStaticCounter() == 500, "L5 static counter should be 500")
    assert(MainL10.getStaticCounter() == 1000, "L10 static counter should be 1000")
    assert(MainL15.getStaticCounter() == 1500, "L15 static counter should be 1500")
    print("PASS\n")

fn test_static_shared_across_aliases(): void =>
    print("test_static_shared_across_aliases: ")
    // L15 and L15_alias should share static state
    var initial: int = MainL15.getStaticCounter()
    MainL15.incrementStatic()
    assert(MainL15_alias.getStaticCounter() == initial + 1, "L15_alias should see L15's static increment")
    // Increment via alias
    MainL15_alias.incrementStatic()
    assert(MainL15.getStaticCounter() == initial + 2, "L15 should see L15_alias's static increment")
    print("PASS\n")

fn test_instance_counters_separate(): void =>
    print("test_instance_counters_separate: ")
    // Instance (non-static) counters should be separate per alias
    var l1_inst: int = L1.getInstanceCounter()
    var l1_alias_inst: int = L1_alias.getInstanceCounter()
    // They start with same value but are independent
    assert(l1_inst == 1, "L1 instance counter should be 1")
    assert(l1_alias_inst == 1, "L1_alias instance counter should be 1")
    // Modify one
    L1.setInstanceCounter(999)
    assert(L1.getInstanceCounter() == 999, "L1 instance counter should be 999")
    assert(L1_alias.getInstanceCounter() == 1, "L1_alias instance counter should still be 1")
    print("PASS\n")

fn test_chain_computation(): void =>
    print("test_chain_computation: ")
    // computeChainValue adds each level's id: 1+2+3+...+15 = 120
    var result: int = L1.computeChainValue(0)
    assert(result == 120, "Chain computation should sum 1..15 = 120")
    // Starting from L5: 5+6+...+15 = 110
    var resultFrom5: int = MainL5.computeChainValue(0)
    assert(resultFrom5 == 110, "Chain from L5 should sum 5..15 = 110")
    // Starting from L10: 10+11+...+15 = 75
    var resultFrom10: int = MainL10.computeChainValue(0)
    assert(resultFrom10 == 75, "Chain from L10 should sum 10..15 = 75")
    print("PASS\n")

fn test_deep_static_access(): void =>
    print("test_deep_static_access: ")
    // Access static counters through the chain
    assert(L1.getDeepStatic() == 200, "L1.getDeepStatic should return L2's static (200)")
    assert(L1.getAliasL7Static() == 700, "L1.getAliasL7Static should return 700")
    assert(L1.getAliasL11Static() == 1100, "L1.getAliasL11Static should return 1100")
    print("PASS\n")

fn test_struct_creation_across_levels(): void =>
    print("test_struct_creation_across_levels: ")
    // Test struct field access via createSummary to avoid namespace-qualified type in declaration
    assert(L1.createSummary().level1Static == 100, "Summary level1Static should be 100")
    assert(L1.createSummary().level2Static == 200, "Summary level2Static should be 200")
    assert(L1.createSummary().level7Static == 700, "Summary level7Static should be 700")
    assert(L1.createSummary().level11Static == 1100, "Summary level11Static should be 1100")
    // Note: L15 static was incremented in earlier test
    assert(L1.createSummary().chainValue == 120, "Summary chainValue should be 120")
    print("PASS\n")

fn test_aggregate_state(): void =>
    print("test_aggregate_state: ")
    // Test aggregate value access via function
    var aggLocal: int = L1.getAggregateLocalVal()
    assert(aggLocal == 200, "Aggregate localVal should be 200")
    print("PASS\n")

fn test_flag_toggle_across_chain(): void =>
    print("test_flag_toggle_across_chain: ")
    // L9 has a static flag, accessed via L2 via L1
    var initial: bool = L1.getL9FlagViaL2()
    assert(initial == true, "L9 flag should initially be true")
    L1.toggleL9FlagViaL2()
    assert(L1.getL9FlagViaL2() == false, "L9 flag should be false after toggle")
    L1.toggleL9FlagViaL2()
    assert(L1.getL9FlagViaL2() == true, "L9 flag should be true after second toggle")
    print("PASS\n")

fn test_direct_vs_chain_access(): void =>
    print("test_direct_vs_chain_access: ")
    // L10 imports L15 directly as DirectL15
    assert(MainL10.verifyDirectAccess() == true, "L10 direct access to L15 should work")
    // MainL10.getDirectDeepStatic() accesses L15's static
    // L15's static was incremented twice earlier
    var directStatic: int = MainL10.getDirectDeepStatic()
    assert(directStatic == MainL15.getStaticCounter(), "Direct and aliased access should see same static")
    print("PASS\n")

fn test_module_struct_instances(): void =>
    print("test_module_struct_instances: ")
    // L5 has a TreeNode struct instance at module level
    var rootVal: int = MainL5.getRootValue()
    assert(rootVal == 50, "L5 root value should be 50")
    MainL5.setRootValue(555)
    assert(MainL5.getRootValue() == 555, "L5 root value should be 555 after set")
    print("PASS\n")

fn test_string_static_vars(): void =>
    print("test_string_static_vars: ")
    // L6 has a static string message
    var msg: str = MainL5.getDeepMessage()
    assert(msg == "level6", "L6 static message should be 'level6'")
    print("PASS\n")

fn test_array_static_vars(): void =>
    print("test_array_static_vars: ")
    // L3 has a static array
    var sum: int = L1.level_02.getStaticArraySumViaL3()
    assert(sum == 93, "L3 static array sum should be 30+31+32=93")
    print("PASS\n")

fn test_multiple_increment_chain(): void =>
    print("test_multiple_increment_chain: ")
    // Increment L1's static multiple times and verify
    var initial: int = L1.getStaticCounter()
    L1.incrementStatic()
    L1.incrementStatic()
    L1.incrementStatic()
    assert(L1.getStaticCounter() == initial + 3, "L1 static should increase by 3")
    // Both aliases should see the same static
    assert(L1_alias.getStaticCounter() == initial + 3, "L1_alias should see same static")
    print("PASS\n")

fn test_cross_level_struct_creation(): void =>
    print("test_cross_level_struct_creation: ")
    // Test struct creation via value extraction to avoid namespace-qualified type declaration
    var stateValue: int = MainL15.createState(42, "test").value
    assert(stateValue == 42, "State value should be 42")
    print("PASS\n")

fn test_bundle_creation(): void =>
    print("test_bundle_creation: ")
    // Test bundle creation via function call
    var bundleId: int = MainL10.getBundleId()
    assert(bundleId == 11, "Bundle id should be 11")
    print("PASS\n")

fn main(): void =>
    print("=== Deep Module Chain Tests (15 levels) ===\n\n")

    test_basic_level_ids()
    test_static_counters_initial()
    test_static_shared_across_aliases()
    test_instance_counters_separate()
    test_chain_computation()
    test_deep_static_access()
    test_struct_creation_across_levels()
    test_aggregate_state()
    test_flag_toggle_across_chain()
    test_direct_vs_chain_access()
    test_module_struct_instances()
    test_string_static_vars()
    test_array_static_vars()
    test_multiple_increment_chain()
    test_cross_level_struct_creation()
    test_bundle_creation()

    print("\nAll deep module chain tests passed!\n")

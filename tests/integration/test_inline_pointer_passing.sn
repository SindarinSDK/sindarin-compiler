# Integration test: Inline pointer passing
# Tests that pointer values from native function calls can be passed
# directly to other native functions without storing in variables.

# Simulated memory allocation - returns a pointer
native fn mock_alloc(size: int): *int =>
    # In real use, this would call C's malloc
    return nil

# Simulated memory deallocation - accepts a pointer
native fn mock_free(ptr: *int): void =>
    # In real use, this would call C's free
    return

# Returns a pointer that can be passed inline
native fn get_resource(): *int =>
    return nil

# Accepts a pointer parameter
native fn use_resource(ptr: *int): void =>
    return

# Returns a pointer and takes a pointer
native fn transform_pointer(ptr: *int): *int =>
    return ptr

# Multiple pointer parameters
native fn combine_resources(a: *int, b: *int): *int =>
    return a

fn main(): int =>
    # Test 1: Basic inline pointer passing (mock_free(mock_alloc(100)))
    mock_free(mock_alloc(100))
    println("Test 1 passed: mock_free(mock_alloc(100))")

    # Test 2: use_handle(get_handle()) pattern
    use_resource(get_resource())
    println("Test 2 passed: use_resource(get_resource())")

    # Test 3: Nested pointer passing (transform result passed inline)
    use_resource(transform_pointer(get_resource()))
    println("Test 3 passed: use_resource(transform_pointer(get_resource()))")

    # Test 4: Multiple inline pointer arguments
    use_resource(combine_resources(get_resource(), get_resource()))
    println("Test 4 passed: combine_resources with two inline get_resource() calls")

    # Test 5: nil can be passed inline
    mock_free(nil)
    println("Test 5 passed: mock_free(nil)")

    println("All inline pointer passing tests passed!")
    return 0

# Test malloc redirect functionality
# Verifies that malloc calls from native code can be redirected to an arena

#pragma source "test_malloc_redirect.sn.c"

# ==============================================================================
# Basic native functions for redirect testing (pure C)
# ==============================================================================
native fn test_redirect_basic(): bool
native fn test_redirect_nested(): bool

# ==============================================================================
# Redirect API exposed to Sindarin
# ==============================================================================
native fn redirect_push(arena): bool      # Push arena as redirect target
native fn redirect_pop(): void            # Pop redirect context
native fn redirect_is_active(): bool      # Check if redirect is active
native fn redirect_depth(): int           # Get current redirect depth

# ==============================================================================
# Native function with arena parameter
# These use rt_arena_alloc directly (no redirect needed)
# ==============================================================================
native fn create_greeting(arena, name: str): str
native fn concat_strings(arena, a: str, b: str): str

# ==============================================================================
# Native struct with native methods
# ==============================================================================
@alias "TestBuffer"
native struct Buffer as ref =>
    _data: *byte
    _size: int
    _capacity: int

    # Static factory using malloc (can be redirected)
    static fn create(size: int): Buffer =>
        return buffer_create(size)

    # Static factory using arena parameter directly
    static fn createInArena(size: int): Buffer =>
        return buffer_create_in_arena(size)

    # Native method - get size
    @alias "buffer_get_size"
    native fn size(): int

    # Native method - get capacity
    @alias "buffer_get_capacity"
    native fn capacity(): int

    # Native method - check if struct is from arena
    @alias "buffer_is_arena_ptr"
    native fn isArenaPtr(): bool

    # Native method - check if data is from arena
    @alias "buffer_data_is_arena_ptr"
    native fn dataIsArenaPtr(): bool

    # Native method - write data (no allocation)
    @alias "buffer_write"
    native fn write(data: str): bool

    # Native method - read as string (uses arena parameter)
    @alias "buffer_read_string"
    native fn readString(arena): str

    # Native method - grow buffer using malloc (can be redirected)
    @alias "buffer_grow"
    native fn grow(additional: int): bool

# Native helpers for Buffer static methods
native fn buffer_create(size: int): Buffer
native fn buffer_create_in_arena(arena, size: int): Buffer

# ==============================================================================
# Test functions
# ==============================================================================

fn test_arena_parameter(): bool =>
    # Test native function with arena parameter (uses rt_arena_alloc directly)
    var greeting: str = create_greeting("World")
    if greeting != "Hello, World!" =>
        print($"Expected 'Hello, World!' but got '{greeting}'\n")
        return false

    var combined: str = concat_strings("foo", "bar")
    if combined != "foobar" =>
        print($"Expected 'foobar' but got '{combined}'\n")
        return false

    return true

fn test_static_method_with_redirect(): bool =>
    # Test: Native struct static method with redirect active
    # buffer_create uses malloc, which should be redirected to arena
    # NOTE: Must check isArenaPtr WHILE redirect is active (before pop)

    if redirect_is_active() =>
        print("Redirect should not be active initially\n")
        return false

    # Push redirect before creating buffer
    if !redirect_push() =>
        print("Failed to push redirect\n")
        return false

    if !redirect_is_active() =>
        print("Redirect should be active after push\n")
        redirect_pop()
        return false

    # Create buffer - malloc should go to arena
    var buf: Buffer = Buffer.create(64)

    # Verify buffer was allocated in arena (must check BEFORE pop)
    if !buf.isArenaPtr() =>
        print("Buffer struct should be from arena\n")
        redirect_pop()
        return false

    if !buf.dataIsArenaPtr() =>
        print("Buffer data should be from arena\n")
        redirect_pop()
        return false

    # Pop redirect
    redirect_pop()

    if redirect_is_active() =>
        print("Redirect should not be active after pop\n")
        return false

    # Verify buffer works correctly (can check after pop)
    if buf.capacity() < 64 =>
        print($"Expected capacity >= 64 but got {buf.capacity()}\n")
        return false

    return true

fn test_static_method_with_arena_param(): bool =>
    # Test: Native struct static method with arena parameter
    # buffer_create_in_arena uses rt_arena_alloc directly (not via redirect)
    # NOTE: isArenaPtr() only tracks redirect allocations, not direct arena allocs

    var buf: Buffer = Buffer.createInArena(64)

    # Verify buffer works correctly
    if buf.capacity() < 64 =>
        print($"Expected capacity >= 64 but got {buf.capacity()}\n")
        return false

    if !buf.write("Test") =>
        print("Failed to write to buffer\n")
        return false

    var content: str = buf.readString()
    if content != "Test" =>
        print($"Expected 'Test' but got '{content}'\n")
        return false

    # Verify we can use the buffer normally
    if !buf.write("More") =>
        print("Failed to write more to buffer\n")
        return false

    if buf.size() != 8 =>
        print($"Expected size 8 but got {buf.size()}\n")
        return false

    return true

fn test_instance_method_with_redirect(): bool =>
    # Test: Native struct instance method with redirect
    # buffer_grow uses malloc, which should be redirected to arena
    # NOTE: Must check isArenaPtr WHILE redirect is active (before pop)

    # Create buffer without redirect - need to push redirect first to check
    # that it's NOT from arena, then pop
    redirect_push()
    var buf: Buffer = Buffer.create(32)

    # Buffer SHOULD be from arena since redirect is active
    if !buf.isArenaPtr() =>
        print("Buffer should be from arena after redirect_push\n")
        redirect_pop()
        return false

    redirect_pop()

    # Write some data
    if !buf.write("Hello") =>
        print("Failed to write initial data\n")
        return false

    # Now grow with redirect active
    if !redirect_push() =>
        print("Failed to push redirect for grow\n")
        return false

    if !buf.grow(64) =>
        print("Failed to grow buffer\n")
        redirect_pop()
        return false

    # After grow, the data pointer should be from arena (check BEFORE pop)
    if !buf.dataIsArenaPtr() =>
        print("Grown buffer data should be from arena\n")
        redirect_pop()
        return false

    redirect_pop()

    # Verify data was preserved
    var content: str = buf.readString()
    if content != "Hello" =>
        print($"Expected 'Hello' after grow but got '{content}'\n")
        return false

    return true

fn test_instance_method_with_arena_param(): bool =>
    # Test: Native struct instance method with arena parameter
    # readString takes arena parameter and allocates result there

    var buf: Buffer = Buffer.create(64)

    if !buf.write("Arena String") =>
        print("Failed to write to buffer\n")
        return false

    # readString uses arena parameter - result is allocated in arena
    var content: str = buf.readString()

    if content != "Arena String" =>
        print($"Expected 'Arena String' but got '{content}'\n")
        return false

    return true

fn test_sindarin_method_with_redirect(): bool =>
    # Test: Sindarin method that manages redirect and verifies results
    # Redirect is pushed, buffer created, results verified, then popped
    # NOTE: isArenaPtr check must happen WHILE redirect is active

    redirect_push()

    # Create buffer using Sindarin factory (calls native buffer_create)
    var buf: Buffer = Buffer.create(64)

    # Verify while redirect is active
    if !buf.isArenaPtr() =>
        print("Buffer struct should be from arena\n")
        redirect_pop()
        return false

    if !buf.dataIsArenaPtr() =>
        print("Buffer data should be from arena\n")
        redirect_pop()
        return false

    redirect_pop()

    # Test the buffer works after redirect is popped
    if !buf.write("Managed") =>
        print("Failed to write to buffer\n")
        return false

    if buf.size() != 7 =>
        print($"Expected size 7 but got {buf.size()}\n")
        return false

    var content: str = buf.readString()
    if content != "Managed" =>
        print($"Expected 'Managed' but got '{content}'\n")
        return false

    return true

fn test_sindarin_method_calls_native_with_redirect(): bool =>
    # Test: Sindarin code that pushes redirect, calls native method, verifies, pops
    # This tests the pattern of wrapping native calls with redirect management

    # Create buffer with redirect active
    redirect_push()
    var buf: Buffer = Buffer.create(32)

    # Verify initial creation was in arena
    if !buf.isArenaPtr() =>
        print("Buffer should be from arena initially\n")
        redirect_pop()
        return false

    redirect_pop()

    if !buf.write("Init") =>
        print("Failed to write initial data\n")
        return false

    # Now grow with redirect - push, call native, check, pop
    redirect_push()

    if !buf.grow(64) =>
        print("Failed to grow buffer\n")
        redirect_pop()
        return false

    # Verify grown data is from arena (check WHILE redirect active)
    if !buf.dataIsArenaPtr() =>
        print("Grown buffer data should be from arena\n")
        redirect_pop()
        return false

    redirect_pop()

    # Verify data was preserved (can check after pop)
    var content: str = buf.readString()
    if content != "Init" =>
        print($"Expected 'Init' after grow but got '{content}'\n")
        return false

    # Append more data to verify buffer still works
    if !buf.write("More") =>
        print("Failed to write after grow\n")
        return false

    content = buf.readString()
    if content != "InitMore" =>
        print($"Expected 'InitMore' but got '{content}'\n")
        return false

    return true

fn test_nested_redirect_from_sindarin(): bool =>
    # Test: Nested redirect scopes from Sindarin
    # NOTE: isArenaPtr checks must happen WHILE redirect is active

    if redirect_depth() != 0 =>
        print($"Expected initial depth 0 but got {redirect_depth()}\n")
        return false

    # Push first scope
    redirect_push()
    if redirect_depth() != 1 =>
        print($"Expected depth 1 but got {redirect_depth()}\n")
        redirect_pop()
        return false

    var buf1: Buffer = Buffer.create(32)

    # Verify buf1 is from arena while in first scope
    if !buf1.isArenaPtr() =>
        print("buf1 should be from arena\n")
        redirect_pop()
        return false

    # Push second scope (nested)
    redirect_push()
    if redirect_depth() != 2 =>
        print($"Expected depth 2 but got {redirect_depth()}\n")
        redirect_pop()
        redirect_pop()
        return false

    var buf2: Buffer = Buffer.create(32)

    # Verify buf2 is from arena while in second scope
    if !buf2.isArenaPtr() =>
        print("buf2 should be from arena\n")
        redirect_pop()
        redirect_pop()
        return false

    # Pop second scope
    redirect_pop()
    if redirect_depth() != 1 =>
        print($"Expected depth 1 after pop but got {redirect_depth()}\n")
        redirect_pop()
        return false

    # Pop first scope
    redirect_pop()
    if redirect_depth() != 0 =>
        print($"Expected depth 0 after pop but got {redirect_depth()}\n")
        return false

    # Verify buffers still work after all pops
    if !buf1.write("test1") =>
        print("Failed to write to buf1\n")
        return false

    if !buf2.write("test2") =>
        print("Failed to write to buf2\n")
        return false

    return true

fn main(): int =>
    print("Testing malloc redirect...\n")

    # Test basic redirect enable/disable (pure C)
    if !test_redirect_basic() =>
        print("FAIL: basic redirect test\n")
        return 1
    print("PASS: basic redirect test\n")

    # Test nested redirect scopes (pure C)
    if !test_redirect_nested() =>
        print("FAIL: nested redirect test\n")
        return 1
    print("PASS: nested redirect test\n")

    # Test native function with arena parameter
    if !test_arena_parameter() =>
        print("FAIL: arena parameter test\n")
        return 1
    print("PASS: arena parameter test\n")

    # Test native struct static method with redirect
    if !test_static_method_with_redirect() =>
        print("FAIL: static method with redirect test\n")
        return 1
    print("PASS: static method with redirect test\n")

    # Test native struct static method with arena parameter
    if !test_static_method_with_arena_param() =>
        print("FAIL: static method with arena param test\n")
        return 1
    print("PASS: static method with arena param test\n")

    # Test native struct instance method with redirect
    if !test_instance_method_with_redirect() =>
        print("FAIL: instance method with redirect test\n")
        return 1
    print("PASS: instance method with redirect test\n")

    # Test native struct instance method with arena parameter
    if !test_instance_method_with_arena_param() =>
        print("FAIL: instance method with arena param test\n")
        return 1
    print("PASS: instance method with arena param test\n")

    # Test Sindarin struct method that manages redirect
    if !test_sindarin_method_with_redirect() =>
        print("FAIL: sindarin method with redirect test\n")
        return 1
    print("PASS: sindarin method with redirect test\n")

    # Test Sindarin method calling native with redirect
    if !test_sindarin_method_calls_native_with_redirect() =>
        print("FAIL: sindarin method calls native with redirect test\n")
        return 1
    print("PASS: sindarin method calls native with redirect test\n")

    # Test nested redirect from Sindarin
    if !test_nested_redirect_from_sindarin() =>
        print("FAIL: nested redirect from sindarin test\n")
        return 1
    print("PASS: nested redirect from sindarin test\n")

    print("All malloc redirect tests passed!\n")
    return 0

// Test: Native struct methods must NOT be interceptable
// Exhaustive testing that interception only applies to user-defined struct methods,
// never to native struct methods (Random, Date, Time, UUID).

import "../../sdk/core/random"
import "../../sdk/time/date"
import "../../sdk/time/time"
import "../../sdk/core/uuid"

var intercepted: bool = false
var intercept_count: int = 0

fn spyInterceptor(name: str, args: any[], continue_fn: fn(): any): any =>
    intercepted = true
    intercept_count = intercept_count + 1
    var result: any = continue_fn()
    return result

// User-defined struct for comparison
struct Counter =>
    value: int

    fn getValue(): int =>
        return self.value

    fn increment(): void =>
        self.value = self.value + 1

    fn add(n: int): int =>
        self.value = self.value + n
        return self.value

    static fn zero(): int =>
        return 0

    static fn fromValue(v: int): int =>
        return v

fn resetSpy(): void =>
    intercepted = false

fn main =>
    var pass_count: int = 0
    var fail_count: int = 0

    // =========================================================================
    // SECTION 1: Verify user-defined struct methods ARE intercepted
    // =========================================================================
    print("=== User-defined struct methods (should be intercepted) ===\n")

    var c: Counter = Counter { value: 10 }

    // Test: Instance method with wildcard
    Interceptor.registerWhere(spyInterceptor, "Counter.*")
    resetSpy()
    var v: int = c.getValue()
    assert(intercepted == true, "Counter.getValue should be intercepted")
    assert(v == 10, "Counter.getValue should return 10")
    pass_count = pass_count + 1
    print("PASS: Counter.getValue intercepted\n")

    // Test: Void instance method
    resetSpy()
    c.increment()
    assert(intercepted == true, "Counter.increment should be intercepted")
    assert(c.value == 11, "Counter.increment should mutate self")
    pass_count = pass_count + 1
    print("PASS: Counter.increment intercepted, self mutated\n")

    // Test: Instance method with args
    resetSpy()
    v = c.add(5)
    assert(intercepted == true, "Counter.add should be intercepted")
    assert(v == 16, "Counter.add should return 16")
    assert(c.value == 16, "Counter.add should mutate self")
    pass_count = pass_count + 1
    print("PASS: Counter.add intercepted, args and self work\n")

    // Test: Static method
    resetSpy()
    v = Counter.zero()
    assert(intercepted == true, "Counter.zero should be intercepted")
    assert(v == 0, "Counter.zero should return 0")
    pass_count = pass_count + 1
    print("PASS: Counter.zero (static) intercepted\n")

    // Test: Static method with args
    resetSpy()
    v = Counter.fromValue(42)
    assert(intercepted == true, "Counter.fromValue should be intercepted")
    assert(v == 42, "Counter.fromValue should return 42")
    pass_count = pass_count + 1
    print("PASS: Counter.fromValue (static) intercepted\n")

    Interceptor.clearAll()

    // =========================================================================
    // SECTION 2: Random - native struct methods must NOT be intercepted
    // =========================================================================
    print("\n=== Random (native struct - should NOT be intercepted) ===\n")

    // Register interceptor with pattern that would match Random methods
    Interceptor.registerWhere(spyInterceptor, "Random.*")

    var rng: Random = Random.create()

    // Test: Random instance methods
    resetSpy()
    var ri: int = rng.nextInt(1, 100)
    assert(intercepted == false, "Random.nextInt must NOT be intercepted")
    assert(ri >= 1, "Random.nextInt should return valid value")
    assert(ri <= 100, "Random.nextInt should return value <= 100")
    pass_count = pass_count + 1
    print("PASS: Random.nextInt not intercepted\n")

    resetSpy()
    var rd: double = rng.nextDouble(0.0, 1.0)
    assert(intercepted == false, "Random.nextDouble must NOT be intercepted")
    assert(rd >= 0.0, "Random.nextDouble should return valid value")
    assert(rd < 1.0, "Random.nextDouble should return value < 1.0")
    pass_count = pass_count + 1
    print("PASS: Random.nextDouble not intercepted\n")

    resetSpy()
    var rb: bool = rng.nextBool()
    assert(intercepted == false, "Random.nextBool must NOT be intercepted")
    pass_count = pass_count + 1
    print("PASS: Random.nextBool not intercepted\n")

    // Test: Random static methods
    resetSpy()
    ri = Random.randInt(1, 50)
    assert(intercepted == false, "Random.randInt must NOT be intercepted")
    assert(ri >= 1, "Random.randInt should return valid value")
    pass_count = pass_count + 1
    print("PASS: Random.randInt (static) not intercepted\n")

    resetSpy()
    rd = Random.randDouble(0.0, 10.0)
    assert(intercepted == false, "Random.randDouble must NOT be intercepted")
    pass_count = pass_count + 1
    print("PASS: Random.randDouble (static) not intercepted\n")

    resetSpy()
    rb = Random.randBool()
    assert(intercepted == false, "Random.randBool must NOT be intercepted")
    pass_count = pass_count + 1
    print("PASS: Random.randBool (static) not intercepted\n")

    Interceptor.clearAll()

    // =========================================================================
    // SECTION 3: Date - native struct methods must NOT be intercepted
    // =========================================================================
    print("\n=== Date (native struct - should NOT be intercepted) ===\n")

    Interceptor.registerWhere(spyInterceptor, "Date.*")

    // Test: Date static methods
    resetSpy()
    var d: Date = Date.today()
    assert(intercepted == false, "Date.today must NOT be intercepted")
    pass_count = pass_count + 1
    print("PASS: Date.today (static) not intercepted\n")

    resetSpy()
    d = Date.fromYmd(2024, 6, 15)
    assert(intercepted == false, "Date.fromYmd must NOT be intercepted")
    pass_count = pass_count + 1
    print("PASS: Date.fromYmd (static) not intercepted\n")

    // Test: Date instance methods
    resetSpy()
    var yr: int = d.year()
    assert(intercepted == false, "Date.year must NOT be intercepted")
    assert(yr == 2024, "Date.year should return 2024")
    pass_count = pass_count + 1
    print("PASS: Date.year not intercepted\n")

    resetSpy()
    var mo: int = d.month()
    assert(intercepted == false, "Date.month must NOT be intercepted")
    assert(mo == 6, "Date.month should return 6")
    pass_count = pass_count + 1
    print("PASS: Date.month not intercepted\n")

    resetSpy()
    var dy: int = d.day()
    assert(intercepted == false, "Date.day must NOT be intercepted")
    assert(dy == 15, "Date.day should return 15")
    pass_count = pass_count + 1
    print("PASS: Date.day not intercepted\n")

    resetSpy()
    var wd: int = d.weekday()
    assert(intercepted == false, "Date.weekday must NOT be intercepted")
    pass_count = pass_count + 1
    print("PASS: Date.weekday not intercepted\n")

    resetSpy()
    var iso: str = d.toIso()
    assert(intercepted == false, "Date.toIso must NOT be intercepted")
    assert(iso == "2024-06-15", "Date.toIso should return correct ISO string")
    pass_count = pass_count + 1
    print("PASS: Date.toIso not intercepted\n")

    resetSpy()
    var d2: Date = d.addDays(10)
    assert(intercepted == false, "Date.addDays must NOT be intercepted")
    pass_count = pass_count + 1
    print("PASS: Date.addDays not intercepted\n")

    resetSpy()
    var before: bool = d.isBefore(d2)
    assert(intercepted == false, "Date.isBefore must NOT be intercepted")
    assert(before == true, "Original date should be before added date")
    pass_count = pass_count + 1
    print("PASS: Date.isBefore not intercepted\n")

    Interceptor.clearAll()

    // =========================================================================
    // SECTION 4: Time - native struct methods must NOT be intercepted
    // =========================================================================
    print("\n=== Time (native struct - should NOT be intercepted) ===\n")

    Interceptor.registerWhere(spyInterceptor, "Time.*")

    // Test: Time static methods
    resetSpy()
    var t: Time = Time.now()
    assert(intercepted == false, "Time.now must NOT be intercepted")
    pass_count = pass_count + 1
    print("PASS: Time.now (static) not intercepted\n")

    resetSpy()
    var t2: Time = Time.fromMillis(1700000000000L)
    assert(intercepted == false, "Time.fromMillis must NOT be intercepted")
    pass_count = pass_count + 1
    print("PASS: Time.fromMillis (static) not intercepted\n")

    // Test: Time instance methods
    resetSpy()
    var ms: long = t.millis()
    assert(intercepted == false, "Time.millis must NOT be intercepted")
    assert(ms > 0L, "Time.millis should return positive value")
    pass_count = pass_count + 1
    print("PASS: Time.millis not intercepted\n")

    resetSpy()
    yr = t2.year()
    assert(intercepted == false, "Time.year must NOT be intercepted")
    pass_count = pass_count + 1
    print("PASS: Time.year not intercepted\n")

    resetSpy()
    var tiso: str = t2.toDate()
    assert(intercepted == false, "Time.toDate must NOT be intercepted")
    pass_count = pass_count + 1
    print("PASS: Time.toDate not intercepted\n")

    resetSpy()
    var t3: Time = t2.add(5000L)
    assert(intercepted == false, "Time.add must NOT be intercepted")
    pass_count = pass_count + 1
    print("PASS: Time.add not intercepted\n")

    resetSpy()
    var tbefore: bool = t2.isBefore(t3)
    assert(intercepted == false, "Time.isBefore must NOT be intercepted")
    assert(tbefore == true, "t2 should be before t3")
    pass_count = pass_count + 1
    print("PASS: Time.isBefore not intercepted\n")

    Interceptor.clearAll()

    // =========================================================================
    // SECTION 5: UUID - native struct methods must NOT be intercepted
    // =========================================================================
    print("\n=== UUID (native struct - should NOT be intercepted) ===\n")

    Interceptor.registerWhere(spyInterceptor, "UUID.*")

    // Test: UUID static methods
    resetSpy()
    var u: UUID = UUID.v4()
    assert(intercepted == false, "UUID.v4 must NOT be intercepted")
    pass_count = pass_count + 1
    print("PASS: UUID.v4 (static) not intercepted\n")

    resetSpy()
    var u2: UUID = UUID.zero()
    assert(intercepted == false, "UUID.zero must NOT be intercepted")
    pass_count = pass_count + 1
    print("PASS: UUID.zero (static) not intercepted\n")

    // Test: UUID instance methods
    resetSpy()
    var ustr: str = u.toString()
    assert(intercepted == false, "UUID.toString must NOT be intercepted")
    pass_count = pass_count + 1
    print("PASS: UUID.toString not intercepted\n")

    resetSpy()
    var uver: int = u.version()
    assert(intercepted == false, "UUID.version must NOT be intercepted")
    assert(uver == 4, "UUID.v4 should have version 4")
    pass_count = pass_count + 1
    print("PASS: UUID.version not intercepted\n")

    resetSpy()
    var unil: bool = u.isNil()
    assert(intercepted == false, "UUID.isNil must NOT be intercepted")
    assert(unil == false, "UUID.v4 should not be nil")
    pass_count = pass_count + 1
    print("PASS: UUID.isNil not intercepted\n")

    resetSpy()
    unil = u2.isNil()
    assert(intercepted == false, "UUID.isNil (zero) must NOT be intercepted")
    assert(unil == true, "UUID.zero should be nil")
    pass_count = pass_count + 1
    print("PASS: UUID.zero.isNil not intercepted\n")

    resetSpy()
    var ueq: bool = u.equals(u2)
    assert(intercepted == false, "UUID.equals must NOT be intercepted")
    assert(ueq == false, "v4 and zero should not be equal")
    pass_count = pass_count + 1
    print("PASS: UUID.equals not intercepted\n")

    Interceptor.clearAll()

    // =========================================================================
    // SECTION 6: Mixed scenario - only user-defined methods intercepted
    // =========================================================================
    print("\n=== Mixed scenario (wildcard * should only catch user-defined) ===\n")

    Interceptor.registerWhere(spyInterceptor, "*")
    c = Counter { value: 100 }

    // User-defined should still be intercepted even with broad wildcard
    resetSpy()
    v = c.getValue()
    assert(intercepted == true, "Counter.getValue should be intercepted with wildcard *")
    pass_count = pass_count + 1
    print("PASS: Counter.getValue intercepted with wildcard *\n")

    // Native should NOT be intercepted even with broad wildcard
    resetSpy()
    ri = Random.randInt(1, 10)
    assert(intercepted == false, "Random.randInt must NOT be intercepted even with *")
    pass_count = pass_count + 1
    print("PASS: Random.randInt not intercepted with wildcard *\n")

    resetSpy()
    d = Date.today()
    assert(intercepted == false, "Date.today must NOT be intercepted even with *")
    pass_count = pass_count + 1
    print("PASS: Date.today not intercepted with wildcard *\n")

    resetSpy()
    t = Time.now()
    assert(intercepted == false, "Time.now must NOT be intercepted even with *")
    pass_count = pass_count + 1
    print("PASS: Time.now not intercepted with wildcard *\n")

    resetSpy()
    u = UUID.v4()
    assert(intercepted == false, "UUID.v4 must NOT be intercepted even with *")
    pass_count = pass_count + 1
    print("PASS: UUID.v4 not intercepted with wildcard *\n")

    Interceptor.clearAll()

    // =========================================================================
    // SECTION 7: Ensure intercept_count is correct overall
    // =========================================================================
    print("\n=== Final verification ===\n")
    // 5 user-defined Counter calls in section 1 + 6 in section 6 (5 resetSpy + 1 getValue)
    assert(intercept_count == 11, $"Expected 11 interceptions, got {intercept_count}")
    pass_count = pass_count + 1
    print($"PASS: Total interception count correct ({intercept_count})\n")

    // =========================================================================
    // Summary
    // =========================================================================
    print($"\n=== Results: {pass_count} passed, {fail_count} failed ===\n")
    assert(fail_count == 0, "All tests should pass")
    print("All native struct interception tests passed!\n")

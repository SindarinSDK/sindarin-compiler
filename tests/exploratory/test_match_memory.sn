# ==============================================================================
# test_match_memory.sn - Match in shared and private memory contexts
# ==============================================================================

struct Label =>
    text: str
    priority: int

# Shared function using match expression to produce a string
shared fn classify_priority(p: int): str =>
    var result: str = match p =>
        1 => "critical"
        2 => "high"
        3 => "medium"
        4, 5 => "low"
        else => "unknown"
    return result

# Shared function using match to return a struct
shared fn create_label(code: int): Label =>
    var text: str = match code =>
        0 => "OK"
        1 => "WARNING"
        2 => "ERROR"
        else => "UNKNOWN"
    var priority: int = match code =>
        0 => 5
        1 => 3
        2 => 1
        else => 4
    return Label { text: text, priority: priority }

# Shared function with match returning a classification string
shared fn process_code(code: int): str =>
    var result: str = match code =>
        200, 201 => "success"
        301, 302 => "redirect"
        404 => "not found"
        500 => "error"
        else => "unknown"
    return result

# Shared function with multiline match arms
shared fn elaborate_status(code: int): str =>
    var prefix: str = "Status"
    var result: str = match code =>
        200 =>
            var msg: str = $"{prefix}: OK"
            msg
        404 =>
            var msg: str = $"{prefix}: Not Found"
            msg
        else =>
            var msg: str = $"{prefix}: Unknown ({code})"
            msg
    return result

# Private function with match (returns int since private can't return str)
private fn private_classify(n: int): int =>
    var result: int = match n =>
        1 => 10
        2 => 20
        3 => 30
        else => 99
    return result

fn test_shared_match_expression(): void =>
    print("test_shared_match_expression: ")
    assert(classify_priority(1) == "critical", "1 should be critical")
    assert(classify_priority(2) == "high", "2 should be high")
    assert(classify_priority(4) == "low", "4 should be low")
    assert(classify_priority(5) == "low", "5 should be low")
    assert(classify_priority(99) == "unknown", "99 should be unknown")
    print("PASS\n")

fn test_shared_match_struct_return(): void =>
    print("test_shared_match_struct_return: ")
    var ok: Label = create_label(0)
    assert(ok.text == "OK", "label 0 text")
    assert(ok.priority == 5, "label 0 priority")

    var warn: Label = create_label(1)
    assert(warn.text == "WARNING", "label 1 text")
    assert(warn.priority == 3, "label 1 priority")

    var err: Label = create_label(2)
    assert(err.text == "ERROR", "label 2 text")
    assert(err.priority == 1, "label 2 priority")
    print("PASS\n")

fn test_shared_match_statement(): void =>
    print("test_shared_match_statement: ")
    assert(process_code(200) == "success", "200")
    assert(process_code(201) == "success", "201")
    assert(process_code(301) == "redirect", "301")
    assert(process_code(404) == "not found", "404")
    assert(process_code(500) == "error", "500")
    assert(process_code(999) == "unknown", "999")
    print("PASS\n")

fn test_shared_match_multiline(): void =>
    print("test_shared_match_multiline: ")
    assert(elaborate_status(200) == "Status: OK", "200 status")
    assert(elaborate_status(404) == "Status: Not Found", "404 status")
    assert(elaborate_status(999) == "Status: Unknown (999)", "999 status")
    print("PASS\n")

fn test_private_match(): void =>
    print("test_private_match: ")
    assert(private_classify(1) == 10, "private 1")
    assert(private_classify(2) == 20, "private 2")
    assert(private_classify(3) == 30, "private 3")
    assert(private_classify(99) == 99, "private 99")
    print("PASS\n")

fn test_private_block_with_match(): void =>
    print("test_private_block_with_match: ")
    var result: int = 0

    private =>
        var code: int = 42
        var v: int = match code =>
            10 => 100
            42 => 420
            else => 0
        result = v

    assert(result == 420, "private block match failed")
    print("PASS\n")

fn test_match_in_loop_shared(): void =>
    print("test_match_in_loop_shared: ")
    var labels: str[] = {}
    for i in 0..4 =>
        var lbl: Label = create_label(i)
        labels.push(lbl.text)
    assert(labels[0] == "OK", "label 0")
    assert(labels[1] == "WARNING", "label 1")
    assert(labels[2] == "ERROR", "label 2")
    assert(labels[3] == "UNKNOWN", "label 3")
    print("PASS\n")

fn main(): void =>
    print("=== Match Memory Context Tests ===\n\n")

    test_shared_match_expression()
    test_shared_match_struct_return()
    test_shared_match_statement()
    test_shared_match_multiline()
    test_private_match()
    test_private_block_with_match()
    test_match_in_loop_shared()

    print("\nAll match memory context tests passed!\n")

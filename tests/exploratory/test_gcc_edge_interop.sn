// Exploratory test: Native/interop edge cases
// Tests pragma and native function patterns that could produce GCC errors
// Focus on header conflicts, signature mismatches, and pragma edge cases

// --- Include a valid system header and use native functions ---
#pragma include <math.h>
#pragma link m

native fn sin(x: double): double
native fn cos(x: double): double
native fn sqrt(x: double): double
native fn pow(x: double, y: double): double
native fn fabs(x: double): double
native fn floor(x: double): double
native fn ceil(x: double): double

fn test_math_natives(): void =>
    var pi: double = 3.141592653589793
    var s: double = sin(pi / 2.0)
    var c: double = cos(0.0)
    var sq: double = sqrt(144.0)
    var p: double = pow(2.0, 10.0)
    var ab: double = fabs(-42.5)
    var fl: double = floor(3.7)
    var ce: double = ceil(3.2)

    print($"sin(pi/2) = {s}\n")
    print($"cos(0) = {c}\n")
    print($"sqrt(144) = {sq}\n")
    print($"pow(2,10) = {p}\n")
    print($"fabs(-42.5) = {ab}\n")
    print($"floor(3.7) = {fl}\n")
    print($"ceil(3.2) = {ce}\n")

// --- Native function that shadows a Sn runtime function name ---
// This tests if the codegen properly handles namespace conflicts
fn test_native_naming(): void =>
    // Call our native functions that have common names
    var result: double = sqrt(25.0)
    print($"sqrt(25) = {result}\n")
    assert(result == 5.0, "sqrt(25) should be 5")

// --- Native function used in complex expressions ---
fn test_native_in_expr(): void =>
    var a: double = sin(0.5) * cos(0.5) + sqrt(2.0) / pow(3.0, 2.0)
    print($"Complex native expr: {a}\n")

    // Native function result in comparison
    if sqrt(16.0) == 4.0 =>
        print("sqrt(16)==4: PASS\n")
    else =>
        print("sqrt(16)==4: FAIL\n")

    // Native function in loop
    var sum: double = 0.0
    for var i: int = 1; i <= 10; i++ =>
        sum = sum + sqrt(i * 1.0)
    print($"Sum of sqrt(1..10): {sum}\n")

// --- Native function result stored in array ---
fn test_native_to_array(): void =>
    var results: double[] = {}
    for var i: int = 0; i < 10; i++ =>
        var angle: double = i * 0.1
        results.push(sin(angle))

    print($"Sin values count: {results.length}\n")
    print($"First sin: {results[0]}\n")
    print($"Last sin: {results[-1]}\n")

// --- Multiple pragma includes ---
#pragma include <string.h>
#pragma include <stdlib.h>
#pragma include <stdio.h>

// These are already included by the runtime, testing that duplicates don't cause issues
fn test_duplicate_includes(): void =>
    // Just verify compilation works with duplicate includes
    print("Duplicate includes test: PASS\n")

// --- Native function with string parameter ---
native fn atoi(s: str): int
native fn atof(s: str): double

fn test_string_native(): void =>
    var i: int = atoi("12345")
    var d: double = atof("3.14159")

    print($"atoi('12345') = {i}\n")
    print($"atof('3.14159') = {d}\n")

// --- Native struct with native function ---
native struct MathResult =>
    value: double
    valid: int

native fn compute_result(x: double): MathResult =>
    var r: MathResult = MathResult { value: sqrt(x), valid: 1 }
    return r

fn test_native_struct(): void =>
    var r: MathResult = compute_result(49.0)
    print($"MathResult: value={r.value} valid={r.valid}\n")

fn main(): void =>
    print("=== Native/Interop Edge Case Tests ===\n\n")

    test_math_natives()
    test_native_naming()
    test_native_in_expr()
    test_native_to_array()
    test_duplicate_includes()
    test_string_native()
    test_native_struct()

    print("\n=== All Interop Tests Done ===\n")

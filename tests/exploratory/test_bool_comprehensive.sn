// Comprehensive test for bool type
// Tests all expression contexts: literals, interpolation,
// logical ops, arrays, any boxing/unboxing, lambdas, functions

fn main(): void =>
    print("=== bool Comprehensive Type Test ===\n\n")

    test_literals()
    test_string_interpolation()
    test_logical_operations()
    test_comparisons()
    test_arrays()
    test_array_equality()
    test_2d_arrays()
    test_any_boxing()
    test_any_unboxing()
    test_type_checking()
    test_lambdas()
    test_functions()
    test_control_flow()
    test_edge_cases()

    print("\n=== All bool tests passed! ===\n")

// --- 1. Literals and Variables ---
fn test_literals(): void =>
    print("1. Literals and variables\n")

    var t: bool = true
    assert(t, "true literal")

    var f: bool = false
    assert(!f, "false literal")

    // Assignment from expression
    var x: bool = 5 > 3
    assert(x, "expression true")

    var y: bool = 5 < 3
    assert(!y, "expression false")

    print("   PASS\n")

// --- 2. String Interpolation ---
fn test_string_interpolation(): void =>
    print("2. String interpolation\n")

    var t: bool = true
    var s1: str = $"Value: {t}"
    assert(s1 == "Value: true", "true interpolation")

    var f: bool = false
    var s2: str = $"Value: {f}"
    assert(s2 == "Value: false", "false interpolation")

    // Expression in interpolation
    var a: int = 5
    var b: int = 3
    var s3: str = $"5 > 3 is {a > b}"
    assert(s3 == "5 > 3 is true", "expression in interpolation")

    // Multiple values
    var s4: str = $"t={t} f={f}"
    assert(s4 == "t=true f=false", "multiple interpolations")

    print("   PASS\n")

// --- 3. Logical Operations ---
fn test_logical_operations(): void =>
    print("3. Logical operations\n")

    // NOT
    assert(!false, "not false")
    assert(!!true, "not not true")

    // AND
    assert(true && true, "true && true")
    assert(!(true && false), "true && false")
    assert(!(false && true), "false && true")
    assert(!(false && false), "false && false")

    // OR
    assert(true || true, "true || true")
    assert(true || false, "true || false")
    assert(false || true, "false || true")
    assert(!(false || false), "false || false")

    // Combined
    assert((true && true) || false, "combined 1")
    assert(true && (true || false), "combined 2")
    assert(!false && true, "combined 3")
    assert(!(false || false) && true, "combined 4")

    // With variables
    var a: bool = true
    var b: bool = false
    assert(a && !b, "var combined")
    assert(!(!a || b), "var combined 2")

    print("   PASS\n")

// --- 4. Comparison Operations ---
fn test_comparisons(): void =>
    print("4. Comparison operations\n")

    var t: bool = true
    var f: bool = false
    var t2: bool = true

    assert(t == t2, "equality true")
    assert(!(t == f), "equality false")

    assert(t != f, "not equal true")
    assert(!(t != t2), "not equal false")

    print("   PASS\n")

// --- 5. Arrays ---
fn test_arrays(): void =>
    print("5. Arrays\n")

    // Array literal
    var arr: bool[] = {true, false, true, false, true}
    assert(arr.length == 5, "array length")

    // Indexing
    assert(arr[0], "index 0")
    assert(!arr[1], "index 1")
    assert(arr[2], "index 2")

    // Negative indexing
    assert(arr[-1], "negative index -1")
    assert(!arr[-2], "negative index -2")

    // Array with expressions
    var x: int = 5
    var arr2: bool[] = {x > 0, x < 0, x == 5}
    assert(arr2[0], "expr in array 0")
    assert(!arr2[1], "expr in array 1")
    assert(arr2[2], "expr in array 2")

    // Slicing
    var slice: bool[] = arr[1..3]
    assert(slice.length == 2, "slice length")
    assert(!slice[0], "slice[0]")
    assert(slice[1], "slice[1]")

    // Empty array
    var empty: bool[] = {}
    assert(empty.length == 0, "empty array")

    // All true
    var allTrue: bool[] = {true, true, true}
    assert(allTrue[0] && allTrue[1] && allTrue[2], "all true")

    // All false
    var allFalse: bool[] = {false, false, false}
    assert(!allFalse[0] && !allFalse[1] && !allFalse[2], "all false")

    print("   PASS\n")

// --- 6. Array Equality ---
fn test_array_equality(): void =>
    print("6. Array equality\n")

    var a: bool[] = {true, false, true}
    var b: bool[] = {true, false, true}
    var c: bool[] = {true, false, false}
    var d: bool[] = {true, false}

    assert(a == b, "equal arrays")
    assert(!(a == c), "different last element")
    assert(!(a == d), "different lengths")

    assert(a != c, "not equal different element")
    assert(a != d, "not equal different length")
    assert(!(a != b), "not not equal")

    // Empty arrays
    var e1: bool[] = {}
    var e2: bool[] = {}
    assert(e1 == e2, "empty arrays equal")

    print("   PASS\n")

// --- 7. 2D Arrays ---
fn test_2d_arrays(): void =>
    print("7. 2D arrays\n")

    var matrix: bool[][] = {{true, false, true}, {false, true, false}, {true, true, true}}

    assert(matrix.length == 3, "2d rows")
    assert(matrix[0].length == 3, "2d cols")

    assert(matrix[0][0], "element [0][0]")
    assert(matrix[1][1], "element [1][1]")
    assert(matrix[2][2], "element [2][2]")

    // Row access
    var row: bool[] = matrix[1]
    assert(!row[0], "row access")

    print("   PASS\n")

// --- 8. Any Boxing ---
fn test_any_boxing(): void =>
    print("8. Any boxing\n")

    var t: bool = true
    var a: any = t
    assert(a is bool, "boxed true type check")

    var f: bool = false
    var b: any = f
    assert(b is bool, "boxed false type check")

    // Boxing array
    var arr: bool[] = {true, false, true}
    var c: any = arr
    assert(c is bool[], "boxed array type check")

    print("   PASS\n")

// --- 9. Any Unboxing ---
fn test_any_unboxing(): void =>
    print("9. Any unboxing\n")

    var t: bool = true
    var a: any = t
    var unboxed: bool = a as bool
    assert(unboxed, "unboxed true")

    var f: bool = false
    var b: any = f
    var unboxed2: bool = b as bool
    assert(!unboxed2, "unboxed false")

    // Unbox array
    var arr: bool[] = {true, false, true}
    var c: any = arr
    var unboxedArr: bool[] = c as bool[]
    assert(unboxedArr.length == 3, "unboxed array length")
    assert(unboxedArr[0], "unboxed array element")

    print("   PASS\n")

// --- 10. Type Checking ---
fn test_type_checking(): void =>
    print("10. Type checking with 'is'\n")

    var t: bool = true
    var a: any = t

    assert(a is bool, "is bool true")
    assert(!(a is int), "is int false")
    assert(!(a is str), "is str false")
    assert(!(a is double), "is double false")

    // Array type checking
    var arr: bool[] = {true, false}
    var b: any = arr
    assert(b is bool[], "is bool[] true")
    assert(!(b is int[]), "is int[] false")

    print("   PASS\n")

// --- 11. Lambdas ---
fn test_lambdas(): void =>
    print("11. Lambdas\n")

    // Lambda with bool parameter
    var negate: fn(bool): bool = fn(x: bool): bool => !x
    assert(!negate(true), "lambda negate true")
    assert(negate(false), "lambda negate false")

    // Lambda with bool return
    var get_true: fn(): bool = fn(): bool => true
    assert(get_true(), "lambda return true")

    // Lambda with expression
    var and_op: fn(bool, bool): bool = fn(a: bool, b: bool): bool => a && b
    assert(and_op(true, true), "lambda and true")
    assert(!and_op(true, false), "lambda and false")

    // Lambda capturing bool
    var flag: bool = true
    var get_flag: fn(): bool = fn(): bool => flag
    assert(get_flag(), "lambda capture")

    // Higher-order with bool
    var apply: fn(fn(bool): bool, bool): bool = fn(f: fn(bool): bool, x: bool): bool => f(x)
    assert(!apply(negate, true), "higher-order lambda")

    print("   PASS\n")

// --- 12. Functions ---
fn test_functions(): void =>
    print("12. Functions\n")

    assert(identity_bool(true), "identity true")
    assert(!identity_bool(false), "identity false")
    assert(and_bool(true, true), "and function")
    assert(or_bool(true, false), "or function")
    assert(!not_bool(true), "not function")

    print("   PASS\n")

fn identity_bool(x: bool): bool =>
    return x

fn and_bool(a: bool, b: bool): bool =>
    return a && b

fn or_bool(a: bool, b: bool): bool =>
    return a || b

fn not_bool(x: bool): bool =>
    return !x

// --- 13. Control Flow ---
fn test_control_flow(): void =>
    print("13. Control flow\n")

    // If with bool
    var flag: bool = true
    var result: int = 0
    if flag =>
        result = 1
    else =>
        result = 0
    assert(result == 1, "if true")

    var flag2: bool = false
    var result2: int = 0
    if flag2 =>
        result2 = 1
    else =>
        result2 = 0
    assert(result2 == 0, "if false")

    // While with bool
    var running: bool = true
    var count: int = 0
    while running =>
        count = count + 1
        if count >= 5 =>
            running = false
    assert(count == 5, "while loop")

    // For loop with bool array
    var trueCount: int = 0
    var arr: bool[] = {true, false, true, true, false}
    for v in arr =>
        if v =>
            trueCount = trueCount + 1
    assert(trueCount == 3, "for loop counting trues")

    print("   PASS\n")

// --- 14. Edge Cases ---
fn test_edge_cases(): void =>
    print("14. Edge cases\n")

    // De Morgan's laws
    var a: bool = true
    var b: bool = false

    // !(a && b) == !a || !b
    assert(!(a && b) == (!a || !b), "de morgan 1")

    // !(a || b) == !a && !b
    assert(!(a || b) == (!a && !b), "de morgan 2")

    // Short-circuit evaluation (conceptual - relies on runtime)
    var x: bool = false
    var y: bool = true
    assert(!(x && y), "short circuit and")
    assert(y || x, "short circuit or")

    // Double negation
    assert(!!true, "double negation true")
    assert(!!false == false, "double negation false")

    // Identity
    assert(true == true, "true == true")
    assert(false == false, "false == false")

    print("   PASS\n")

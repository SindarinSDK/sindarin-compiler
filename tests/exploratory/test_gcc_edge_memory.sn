// Exploratory test: Memory/arena edge cases
// Tests private blocks, as-ref semantics, and arena management patterns

// --- Nested private blocks ---
fn test_nested_private(): void =>
    var outer: int = 0

    private =>
        var a: int = 1
        outer = outer + a

        private =>
            var b: int = 2
            outer = outer + b

            private =>
                var c: int = 3
                outer = outer + c

                private =>
                    var d: int = 4
                    outer = outer + d

                    private =>
                        var e: int = 5
                        outer = outer + e

    print($"Nested private sum: {outer}\n")
    assert(outer == 15, "1+2+3+4+5=15")

// --- Private block with array allocation ---
fn test_private_arrays(): void =>
    var result: int = 0

    private =>
        var temp: int[] = {1, 2, 3, 4, 5}
        for v in temp =>
            result = result + v

    print($"Private array sum: {result}\n")
    assert(result == 15, "1+2+3+4+5=15")

// --- Private block with string operations ---
fn test_private_strings(): void =>
    var final_length: int = 0

    private =>
        var s: str = "hello"
        s = s + " world"
        s = s + "!"
        final_length = s.length

    print($"Private string length: {final_length}\n")
    assert(final_length == 12, "hello world! = 12 chars")

// --- As-ref on primitives ---
fn test_as_ref_primitives(): void =>
    var x: int as ref = 42
    var y: int as ref = 100
    var z: double as ref = 3.14

    print($"as ref: x={x} y={y} z={z}\n")

    x = x + 1
    y = y * 2
    z = z + 1.0

    print($"modified: x={x} y={y} z={z}\n")

// --- As-ref passed to function ---
fn modify_ref(x: int as ref): void =>
    x = x + 100

fn test_ref_passing(): void =>
    var v: int as ref = 5
    print($"Before: {v}\n")
    modify_ref(v)
    print($"After modify_ref: {v}\n")

// --- Private block inside loop ---
fn test_private_in_loop(): void =>
    var total: int = 0

    for var i: int = 0; i < 10; i++ =>
        private =>
            var temp: int[] = {}
            for var j: int = 0; j <= i; j++ =>
                temp.push(j)
            total = total + temp.length

    print($"Private in loop total: {total}\n")
    assert(total == 55, "Sum of 1..10 = 55")

// --- Private block with struct ---
struct TempData =>
    values: int[] = {}
    count: int = 0

fn test_private_struct(): void =>
    var final_count: int = 0

    private =>
        var data: TempData = TempData {}
        data.values.push(10)
        data.values.push(20)
        data.values.push(30)
        data.count = data.values.length
        final_count = data.count

    print($"Private struct count: {final_count}\n")
    assert(final_count == 3, "Should have 3 items")

// --- Multiple private blocks in sequence ---
fn test_sequential_private(): void =>
    var r1: int = 0
    var r2: int = 0
    var r3: int = 0

    private =>
        var x: int[] = {1, 2, 3}
        r1 = x.length

    private =>
        var y: int[] = {4, 5, 6, 7}
        r2 = y.length

    private =>
        var z: int[] = {8, 9}
        r3 = z.length

    print($"Sequential private: {r1} {r2} {r3}\n")
    assert(r1 == 3, "First block: 3")
    assert(r2 == 4, "Second block: 4")
    assert(r3 == 2, "Third block: 2")

// --- As-val copy semantics ---
fn test_as_val(): void =>
    var original: int[] = {1, 2, 3, 4, 5}
    var copy: int[] as val = original

    copy.push(6)

    print($"Original length: {original.length}\n")
    print($"Copy length: {copy.length}\n")
    assert(original.length == 5, "Original unchanged")
    assert(copy.length == 6, "Copy has new element")

// --- Shared function ---
shared fn helper(x: int, y: int): int =>
    return x + y

fn test_shared_function(): void =>
    var r: int = helper(10, 20)
    print($"Shared function: {r}\n")
    assert(r == 30, "10+20=30")

// --- Private block with lambda ---
fn test_private_lambda(): void =>
    var result: int = 0

    private =>
        var multiplier: int = 10
        var f: fn(int): int = fn(x: int): int => x * multiplier
        result = f(5)

    print($"Private lambda result: {result}\n")
    assert(result == 50, "5*10=50")

fn main(): void =>
    print("=== Memory/Arena Edge Case Tests ===\n\n")

    test_nested_private()
    test_private_arrays()
    test_private_strings()
    test_as_ref_primitives()
    test_ref_passing()
    test_private_in_loop()
    test_private_struct()
    test_sequential_private()
    test_as_val()
    test_shared_function()
    test_private_lambda()

    print("\n=== All Memory Tests Done ===\n")
